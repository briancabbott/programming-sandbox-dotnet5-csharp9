


/** 

   >> Its time to beat NumPy. I think I can do better. It starts here.  
         with: Number =>                "Infinite Value Manifestation", 
               Number_subscript[a] =>   "Value Manifestation" from "Aspect" (Perception from Point-Angle relationship of calculation).
      
      This class captures both Number and Number[a] (where a is the form/value used in a specific calculation)
         - hack in a form of auto-box/unbox for originating-value/aspect relationship. 
*/
public class Number {

    // stores all manifestations of a value simultaneously. 
    // once core value is captured on create, create the other projections in background threads, making immediately available the core "client-call-site-immediate"

    // create an 'infinite' registers for both sign(s), values, decimal
    // create 'fast-form' where values reside within extrememly fixed registers. 


}


// Growable memory space (in big-endian) to hold a set of bits participating in some part of a given value membership for Number[a].
public class NumberRegister {
    
    // a register of growable width, big-endian ordering.
    private byte[] internal_register;

    GetLittleEndian()
    
    // Helps determine when to grow the array
    IsCarryOver()
}


// An aggregate of number registers forming the value of a number-aspect
public class NumberRegisterAggregate {} 


// Records a specific operation (core-internal-engine operation) on a number such that, a sequence of them can (via error-coding, etc) determine if something went wrong and, all retreivablity (effectively creating an stack sequence on each Number, enabling a kind of immutablility via retrievability)
NumberOperation (info about the point of operation execution itself (ReferenceEquals a compiler generated measurement set of the code))
NumberOperationRecord 
{

}